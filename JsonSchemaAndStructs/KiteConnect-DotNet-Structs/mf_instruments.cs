// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using MfInstruments;
//
//    var mfInstruments = MfInstruments.FromJson(jsonString);

namespace MfInstruments
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class MfInstruments
    {
        [JsonProperty("amc", NullValueHandling = NullValueHandling.Ignore)]
        public Amc? Amc { get; set; }

        [JsonProperty("dividend_type", NullValueHandling = NullValueHandling.Ignore)]
        public DividendType? DividendType { get; set; }

        [JsonProperty("last_price", NullValueHandling = NullValueHandling.Ignore)]
        public double? LastPrice { get; set; }

        [JsonProperty("last_price_date", NullValueHandling = NullValueHandling.Ignore)]
        public DateTimeOffset? LastPriceDate { get; set; }

        [JsonProperty("minimum_additional_purchase_amount", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinimumAdditionalPurchaseAmount { get; set; }

        [JsonProperty("minimum_purchase_amount", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinimumPurchaseAmount { get; set; }

        [JsonProperty("minimum_redemption_quantity", NullValueHandling = NullValueHandling.Ignore)]
        public double? MinimumRedemptionQuantity { get; set; }

        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        [JsonProperty("plan", NullValueHandling = NullValueHandling.Ignore)]
        public Plan? Plan { get; set; }

        [JsonProperty("purchase_allowed", NullValueHandling = NullValueHandling.Ignore)]
        public long? PurchaseAllowed { get; set; }

        [JsonProperty("purchase_amount_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public long? PurchaseAmountMultiplier { get; set; }

        [JsonProperty("redemption_allowed", NullValueHandling = NullValueHandling.Ignore)]
        public long? RedemptionAllowed { get; set; }

        [JsonProperty("redemption_quantity_multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? RedemptionQuantityMultiplier { get; set; }

        [JsonProperty("scheme_type", NullValueHandling = NullValueHandling.Ignore)]
        public SchemeType? SchemeType { get; set; }

        [JsonProperty("settlement_type", NullValueHandling = NullValueHandling.Ignore)]
        public SettlementType? SettlementType { get; set; }

        [JsonProperty("tradingsymbol", NullValueHandling = NullValueHandling.Ignore)]
        public string Tradingsymbol { get; set; }
    }

    public enum Amc { BirlaSunLifeMutualFundMf };

    public enum DividendType { Growth, Payout };

    public enum Plan { Direct, Regular };

    public enum SchemeType { Balanced, Debt, Equity, Fof, Liquid };

    public enum SettlementType { T1, T3, T4, T6 };

    public partial class MfInstruments
    {
        public static MfInstruments[] FromJson(string json) => JsonConvert.DeserializeObject<MfInstruments[]>(json, MfInstruments.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this MfInstruments[] self) => JsonConvert.SerializeObject(self, MfInstruments.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                AmcConverter.Singleton,
                DividendTypeConverter.Singleton,
                PlanConverter.Singleton,
                SchemeTypeConverter.Singleton,
                SettlementTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class AmcConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Amc) || t == typeof(Amc?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "BirlaSunLifeMutualFund_MF")
            {
                return Amc.BirlaSunLifeMutualFundMf;
            }
            throw new Exception("Cannot unmarshal type Amc");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Amc)untypedValue;
            if (value == Amc.BirlaSunLifeMutualFundMf)
            {
                serializer.Serialize(writer, "BirlaSunLifeMutualFund_MF");
                return;
            }
            throw new Exception("Cannot marshal type Amc");
        }

        public static readonly AmcConverter Singleton = new AmcConverter();
    }

    internal class DividendTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DividendType) || t == typeof(DividendType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "growth":
                    return DividendType.Growth;
                case "payout":
                    return DividendType.Payout;
            }
            throw new Exception("Cannot unmarshal type DividendType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DividendType)untypedValue;
            switch (value)
            {
                case DividendType.Growth:
                    serializer.Serialize(writer, "growth");
                    return;
                case DividendType.Payout:
                    serializer.Serialize(writer, "payout");
                    return;
            }
            throw new Exception("Cannot marshal type DividendType");
        }

        public static readonly DividendTypeConverter Singleton = new DividendTypeConverter();
    }

    internal class PlanConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Plan) || t == typeof(Plan?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "direct":
                    return Plan.Direct;
                case "regular":
                    return Plan.Regular;
            }
            throw new Exception("Cannot unmarshal type Plan");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Plan)untypedValue;
            switch (value)
            {
                case Plan.Direct:
                    serializer.Serialize(writer, "direct");
                    return;
                case Plan.Regular:
                    serializer.Serialize(writer, "regular");
                    return;
            }
            throw new Exception("Cannot marshal type Plan");
        }

        public static readonly PlanConverter Singleton = new PlanConverter();
    }

    internal class SchemeTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SchemeType) || t == typeof(SchemeType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "balanced":
                    return SchemeType.Balanced;
                case "debt":
                    return SchemeType.Debt;
                case "equity":
                    return SchemeType.Equity;
                case "fof":
                    return SchemeType.Fof;
                case "liquid":
                    return SchemeType.Liquid;
            }
            throw new Exception("Cannot unmarshal type SchemeType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SchemeType)untypedValue;
            switch (value)
            {
                case SchemeType.Balanced:
                    serializer.Serialize(writer, "balanced");
                    return;
                case SchemeType.Debt:
                    serializer.Serialize(writer, "debt");
                    return;
                case SchemeType.Equity:
                    serializer.Serialize(writer, "equity");
                    return;
                case SchemeType.Fof:
                    serializer.Serialize(writer, "fof");
                    return;
                case SchemeType.Liquid:
                    serializer.Serialize(writer, "liquid");
                    return;
            }
            throw new Exception("Cannot marshal type SchemeType");
        }

        public static readonly SchemeTypeConverter Singleton = new SchemeTypeConverter();
    }

    internal class SettlementTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SettlementType) || t == typeof(SettlementType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "T1":
                    return SettlementType.T1;
                case "T3":
                    return SettlementType.T3;
                case "T4":
                    return SettlementType.T4;
                case "T6":
                    return SettlementType.T6;
            }
            throw new Exception("Cannot unmarshal type SettlementType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SettlementType)untypedValue;
            switch (value)
            {
                case SettlementType.T1:
                    serializer.Serialize(writer, "T1");
                    return;
                case SettlementType.T3:
                    serializer.Serialize(writer, "T3");
                    return;
                case SettlementType.T4:
                    serializer.Serialize(writer, "T4");
                    return;
                case SettlementType.T6:
                    serializer.Serialize(writer, "T6");
                    return;
            }
            throw new Exception("Cannot marshal type SettlementType");
        }

        public static readonly SettlementTypeConverter Singleton = new SettlementTypeConverter();
    }
}
